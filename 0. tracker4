11/01: updated few old codes.
11/02: 
      221. Maximal Square: 使用dp的算法，只是在transistion的部分比较麻烦。的确我也没有想到；这里面的最为重要的点是，dp[i][j] = min (dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1。 其实一个点能够有一个非1的正方形就代表着这个点能在当前的边上有x个连续的1，如果当前点也为一的话，那必然使应该加一的
      222. Count Complete Tree Nodes: 使用的是分治法来得到结果，我通过这个明白了，只需要清晰的定义好自己的函数，然后就可以recursion了，不要一个一个考虑太浪费时间了。写code前要思考这段代码的含义
      223: Rectanglue Area: 题目非常的奇怪，非常的简单，是基本的数学题。
11/03: None @ weekend
11/04: None @ weekend
11/05: None @ weekend
11/06: 
      227. Basic Calculator II： 这是基本的运算方法，在这里面，处理的方法还是很有趣的。它其实就是simulate人脑的想法然后向前不断的推进
      228. Summary Ranges： 不知道为什么，我觉得这道题还是非常的简单的。而且我的答案居然超过了98%的人，奇怪。
      229. Majority Element II: 也是很简单的题目，我又把问题想难了，其实我一开始就用最为简单的方法做出来，不要说去用那些复杂的方法了。 在网上看了看，发现了其中的一个叫做Boyer–Moore_majority_vote_algorithm 的东。我自己写的东西其实不满足题目中说的O(1) space的要求啊
11/07: 
      230: Kth Smallest Element in a BST: 我以前学的那些in order, post order and pre order的算法需要复习一下了。其实就是给binary tree排序
      236: Lowest Common Ancestor of a Binary Tree： 一次就写过了，还是很不错的。
      238. Product of Array Except Self: 这个算法很巧妙，只是好奇是怎么想到的。一个俩遍的遍历就可以得到这个结果

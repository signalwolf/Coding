11/01: updated few old codes.
11/02: 
      221. Maximal Square: 使用dp的算法，只是在transistion的部分比较麻烦。的确我也没有想到；这里面的最为重要的点是，dp[i][j] = min (dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1。 其实一个点能够有一个非1的正方形就代表着这个点能在当前的边上有x个连续的1，如果当前点也为一的话，那必然使应该加一的
      222. Count Complete Tree Nodes: 使用的是分治法来得到结果，我通过这个明白了，只需要清晰的定义好自己的函数，然后就可以recursion了，不要一个一个考虑太浪费时间了。写code前要思考这段代码的含义
      223: Rectanglue Area: 题目非常的奇怪，非常的简单，是基本的数学题。
